[{"title":"深入理解JVM（二）-类加载机制","date":"2017-10-01T07:44:04.000Z","path":"2017/10/01/深入理解JVM（二）-类加载机制/","text":"类加载机制虚拟机把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 类加载过程：类装载器把一个类装入JVM中 (1) 加载：查找和导入Class文件； (2) 链接：把类的二进制数据合并到JRE中； (a)校验：检查载入Class文件数据的正确性； (b)准备：给类的静态变量分配存储空间； (c)解析：将符号引用转成直接引用； (3) 初始化：对类的静态变量，静态代码块执行初始化操作（执行类构造器clinit()的过程） 动态扩展Java程序可以动态扩展是由运行期动态加载和动态链接实现的；比如：如果编写一个使用接口的应用程序，可以等到运行时再指定其实际的实现(多态)，解析过程有时候还可以在初始化之后执行；比如：动态绑定(多态)； 类加载器的代理模式：双亲委托机制就是某个特定的类加载器在接收到加载类的请求后，首先将加载任务委托给父类加载器，一次追溯，直到最高的爷爷辈的，如果父类加载器可以完成类加载任务，就成功返回；只要父类加载器无法完成次加载任务时，才自己加载。 双亲机制是为了保证java核心库的类型安全，不会出现用户自己能定义java.lang.Object类的情况。","tags":[{"name":"深入理解JVM","slug":"深入理解JVM","permalink":"http://DeveloperYangyang.github.io/tags/深入理解JVM/"}]},{"title":"深入理解JVM（一）-JVM内存模型","date":"2017-10-01T07:41:14.000Z","path":"2017/10/01/深入理解JVM（一）-JVM内存模型/","text":"JVM内存模型Java程序执行过程 Java源代码文件(.java)会被Java编译器编译为字节码文件(.class) 由JVM中的类加载器加载各个类的字节码文件(.class) JVM执行引擎执行 在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这 段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。 JVM内存分布 Runtime Data Area（运行时数据区）包括 ： Java栈(VM Stack)、本地方法栈(Native Method Stack)、程序计数器(Program Counter Register)、堆(Heap)、方法区(Method Area) 1. Java栈Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池（运行时常量池的概念在方法区部分会谈到）的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息。 2. 本地方法栈本地方法栈则是为执行本地方法（Native Method）服务的 3. 程序计数器用来指示执行哪条指令的，每个线程都需要有自己独立的程序计数器。 由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。 4. 堆堆是用来存储对象本身的以及数组 Java 垃圾收集器管理的主要区域 堆是被所有线程共享的，在JVM中只有一个堆 5. 方法区方法区是被线程共享的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。 运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来","tags":[{"name":"深入理解JVM","slug":"深入理解JVM","permalink":"http://DeveloperYangyang.github.io/tags/深入理解JVM/"}]},{"title":"前缀，中缀，后缀表达式转换","date":"2017-09-10T11:45:09.000Z","path":"2017/09/10/前缀，中缀，后缀表达式转换/","text":"1 基本概念​ 在计算机中表达式有三种，前缀表达式（波兰式），中缀表达式，后缀表达式（逆波兰式）。 如表达式：a+b*(c-d)-e/f 前缀表达式：-+a*b-cd/ef 中缀表达式：a+b*(c-d)-e/f 后缀表达式：abcd-*+ef/- 2 转换原理​ 原理不难，我们遇到遇到操作数的时候直接输出，当遇到操作符（包括‘（’，‘+’，‘-’，‘*’，‘/’）的时候，我们需要把符号压入到栈中， 2.1 当遇到‘）’的时候： ​ 我们需要依次从栈顶弹出符号，直到遇到‘（’，并且要将‘（’弹出。如：（a（b+c）），栈中的是（（+，当遇到‘）’的时候，我们要弹出‘+’，‘（’。 2.2 当遇到‘（’的时候 ​ 此时没什么要说的，直接压栈。 2.3 当遇到‘+’，‘-’，‘*’，‘/’的时候： ​ 我们要把栈顶元素的符号的优先级跟输入的符号的优先级进行对比，如果栈顶优先级高的话，我们就要把栈顶元素依次弹出，直到栈顶的优先级低于输入的优先级或者栈空。 如：a+b+c+d，跟a+b*c+d得到的符号顺序就不一样，原因就是这个优先级的问题。 2.4 当遇到操作数的时候： ​ 毫无疑问，直接输出 例题：简便方法中缀表达式(a+b) c (d-e/f) 转成前缀，后缀表达式 第一步：按照运算符的优先级对所有的运算单位加括号：式子变成了：((a+(b*c))-(d+e)) 第二步：转换前缀与后缀表达式 前缀：把运算符号移动到对应的括号前面,则变成拉：-( +(a (bc)) +(de)) 。把括号去掉：-+abc+de 前缀式子出现 后缀：把运算符号移动到对应的括号后面，则变成拉：((a(bc) )+ (de)+ )- 。把括号去掉：abc+de+- 后缀式子出现","tags":[{"name":"算法","slug":"算法","permalink":"http://DeveloperYangyang.github.io/tags/算法/"}]},{"title":"剑指offer-（6-10）","date":"2017-09-07T06:26:53.000Z","path":"2017/09/07/剑指offer-（6-10）/","text":"6.旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 考点：查找 一般查找与排序一同出现，掌握二分查找，归并排序和快速排序（必须掌握）。算法比较：额外空间消耗，平均时间复杂度和最差时间复杂度等 如果在一个已经排序或者部分排序的数组中查找一个数字或者统计数字出现次数，尝试使用二分查找 本题通过直接遍历能直接得出，时间复杂度为O(n)。利用旋转特性，使用二分法实现O(logn) 1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if (array.length == 0) &#123; System.out.println(&quot;Invalid parameters&quot;); &#125; int index1 = 0; int index2 = array.length - 1; int indexmid = index1; while (array[index1] &gt;= array[index2]) &#123; if (index2 - index1 == 1) &#123; indexmid = index2; break; &#125; indexmid = (index1 + index2) / 2; if (array[index1] == array[index2] &amp;&amp; array[indexmid] == array[index1]) &#123; return MinInOrder(array, index1, index2); &#125; if (array[indexmid] &gt;= array[index1]) &#123; index1 = indexmid; &#125; else if (array[indexmid] &lt;= array[index2]) &#123; index2 = indexmid; &#125; &#125; return array[indexmid]; &#125; private static int MinInOrder(int[] array, int index1, int index2)&#123; int result = array[index1]; for (int i = index1 +1; i &lt;= index2; ++i)&#123; if (result &gt; array[i]) &#123; result = array[i]; &#125; &#125; return result; &#125;&#125; 7. 斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 n&lt;=39 123456789101112131415161718public class Solution &#123; public int Fibonacci(int n) &#123; int[] result = &#123;0, 1&#125;; if (n &lt; 2) &#123; return result[n]; &#125; int fibMinusOne = 1; int fibMinusTwo = 0; int fibN = 0; for (int i = 2; i &lt;= n; ++i) &#123; fibN = fibMinusOne + fibMinusTwo; fibMinusTwo = fibMinusOne; fibMinusOne = fibN; &#125; return fibN; &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://DeveloperYangyang.github.io/tags/算法/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://DeveloperYangyang.github.io/tags/剑指offer/"}]},{"title":"剑指offer-（1-5）","date":"2017-09-01T14:40:06.000Z","path":"2017/09/01/剑指offer-（1-5）/","text":"1.二维数组中的查找 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 考点：数组 1.直接使用两次嵌套遍历。时间复杂度O(n^2) 123456789101112public class Solution &#123; public boolean Find(int [][] array,int target) &#123; for(int i=0;i&lt;array.length;i++)&#123; for(int j=0;j&lt;array[i].length;j++)&#123; if(array[i][j]==target)&#123; return true; &#125; &#125; &#125; return false; &#125; &#125; 2.改进：根据题目，每行每列都是递增，则找到矩阵右上角数字，判断它和target大小，它小则行减1，它大则列减一。时间复杂度O(n) 1234567891011121314151617181920212223public class Problem_1 &#123; public static boolean Find(int[][] array, int target) &#123; boolean found = false; int rows = array.length; int columns = array[0].length; if (array != null &amp;&amp; rows &gt; 0 &amp;&amp; columns &gt; 0 ) &#123; int row = 0; int column = columns - 1; while (row &lt; rows &amp;&amp; column &gt;= 0) &#123; if (array[row][column] == target) &#123; found = true; break; &#125; else if (array[row][column] &gt; target) &#123; --column; &#125; else ++row; &#125; &#125; return found; &#125;&#125; 2.替换空格 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。考点：字符串 1234567public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; String str1 = str.toString(); String str2 = str1.replace(&quot; &quot;, &quot;%20&quot;); return str2; &#125;&#125; 3.从尾到头打印链表 输入一个链表，从尾到头打印链表每个节点的值。 考点：链表解题点：先进后出，使用栈。递归的本质就是栈。使用栈 1234567891011121314151617181920212223242526272829/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.Stack;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; sk = new Stack&lt;Integer&gt;(); while(listNode!=null) &#123; sk.push(listNode.val); listNode=listNode.next; &#125; ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;(); while(!sk.isEmpty()) &#123; al.add(sk.pop()); &#125; return al; &#125;&#125; 使用递归 12345678910111213141516171819202122232425262728/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (list == null)&#123; return list; &#125; ListNode pnode = listNode; if(pnode != null)&#123; if(pnode.next != null)&#123; list = printListFromTailToHead(pnode.next); &#125; list.add(pnode.val); &#125; return list; &#125;&#125; 当链表很长时，则函数调用层级很深，导致函数调用栈溢出。 4.重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 考点：二叉树先序中序后序遍历的实现方法都有递归和循环实现方法。求最大（最小值）时可以使用最大（最小）堆来解决。 1.根据先序和中序的特点，根据先序第一个值找到根节点; 2.在中序中找到根节点，则根节点前面就是左子树，后面就是右子树； 3.通过递归，构建新二叉树的左子树和右子树。 12345678910111213141516171819202122232425262728/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; TreeNode root = inputTree(pre, 0, pre.length-1, in, 0, in.length-1); return root; &#125; public TreeNode inputTree(int[] pre, int startPre, int endPre, int[] in, int startIn, int endIn)&#123; if(startPre &gt; endPre || startIn &gt; endIn)&#123; return null; &#125; TreeNode root = new TreeNode(pre[startPre]); for(int i=startIn;i&lt;=endIn;i++)&#123; if(in[i]==pre[startPre])&#123; root.left=inputTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1); root.right=inputTree(pre,startPre+i-startIn+1,endPre,in,i+1,endIn); &#125; &#125; return root; &#125;&#125; 5.用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 考点：栈和队列 栈：先去后出；队列：先进先出 12345678910111213141516171819202122import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(new Integer(node)); &#125; public int pop() &#123; if(stack2.empty())&#123; while(!stack1.empty())&#123; stack2.push(stack1.pop()); &#125; &#125; if(stack2.empty())&#123; System.out.println(&quot;null&quot;); &#125; return stack2.pop().intValue(); &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://DeveloperYangyang.github.io/tags/算法/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://DeveloperYangyang.github.io/tags/剑指offer/"}]},{"title":"Mac安装MySQL解决root密码问题","date":"2017-08-16T08:51:30.000Z","path":"2017/08/16/Mac安装MySQL解决root密码问题/","text":"mac重置mysql的root密码方法记录原因：在MySQL安装过程中，有一步给你一个初始Root密码。由于自己没有记录导致下面的问题👇：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO) 解决办法：学自别人的blog MySQL中提供了一种免去密码校验进入数据库的方法，使用这种方法登入到数据库，将默认密码替换掉。 一、找到Mysql配置文件使用指令 12345cd /usr/local/mysqllscd support-files/lssudo vim my-default.cnf 注意：使用sudo，因为my-default.cnf配置文件不具备写权限。 二、修改配置文件打开刚才我们找到的配置文件，然后在里面找到 [mysqld] 这一项，然后在该配置项下添加 12skip-grant-tables 这个配置，然后保存文件。 三、重启mysql服务在系统偏好中进行重启 四、免密登录MySQL然后再次进入到终端当中，敲入 12mysql -u root -p 命令然后回车，当需要输入密码时，直接按enter键，便可以不用密码登录到数据库当中 五、修改默认的密码使用 12set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;新密码&apos;); 命令修改新的密码。 六、检验成果我们改完默认密码后，再次进入到之前的配置文件中，将我们跳过密码的那个配置行给删除掉，变为系统原先的配置。重启MySQL服务，下次再登录的时候便可以解决掉这个问题了。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://DeveloperYangyang.github.io/tags/MySQL/"}]},{"title":"牛客20170809算法总结","date":"2017-08-15T08:49:44.000Z","path":"2017/08/15/牛客20170809算法总结/","text":"0.铺垫：数组中的最大子数组1234567891011121314151617181920 public class SubArrayMaxSum &#123; public static int maxSum(int[] arr) &#123; if (arr == null || arr.length == 0)&#123; return 0; &#125; int max = Integer.MIN_VALUE; int cur = 0; for (int i = 0; i != arr.length; i++)&#123; cur += arr[i]; max = Math.max(max, cur); cur = cur &lt; 0 ? 0:cur; &#125; return max; &#125; public static void main(String[] args)&#123; int[] arr1 = &#123;-2, -3, -5, 40, -10, -10, 100, 1&#125;; System.out.println(maxSum(arr1)); &#125;&#125; 1.给定一个矩阵matrix，其中的值有正、有负、有0，返回子矩阵 的最大累加和。例如，矩阵matrix为: -90 48 78 64 -40 64 -81 -7 66 其中，最大累加和的子矩阵为: 48 78 -40 64 -7 66 所以返回累加和209。 例如，matrix为: -1 -1 -1 -1 2 2 -1 -1 -1 其中，最大累加和的子矩阵为: 2 2 所以返回累加和4。 1234567891011121314151617181920212223242526272829public class SubMatrixMaxSum &#123; public static int maxSum(int[][] m)&#123; if (m == null || m.length == 0 || m[0].length ==0)&#123; return 0; &#125; int max = Integer.MIN_VALUE; int cur = 0; int[] s = null; for (int i = 0; i != m.length; i++)&#123; s = new int[m[0].length]; for (int j = i; j != m[0].length; j++)&#123; cur = 0; for (int k =0; k != s.length; k++)&#123; s[k] += m[j][k]; cur += s[k]; max = Math.max(max, cur); cur = cur &lt; 0 ? 0 : cur; &#125; &#125; &#125; return max; &#125; public static void main(String[] args)&#123; int[][] matrix =&#123;&#123; -90, 48, 78 &#125;, &#123; 64, -40, 64 &#125;, &#123; -81, -7, 66 &#125;&#125;; System.out.println(maxSum(matrix)); &#125;&#125; 关键点：累加 2.给定一个数组，每个位置的值代表一个高度。那么整个数组可以看过是一个直方图。如果把这个直方图当做容器的话，求这个容器能装多少水。例如:3,1,2,4 代表第一个位置高度为3，第二个位置高度为1，第三个位置高度为2， 第四个位置高度为4。3,1,2,4这个数组代表的容器可以装3格的水。 123456789101112131415161718192021222324252627282930public class WaterMaxProblem &#123; public static int getWater(int[] arr)&#123; if (arr == null || arr.length &lt; 3)&#123; return 0; &#125; int value = 0; int leftMax = arr[0]; int rightMax = arr[arr.length - 1]; int l = 1; int r = arr.length - 2; while ( l &lt;= r)&#123; if (leftMax &lt;= rightMax)&#123; value += Math.max(0, leftMax - arr[l]); leftMax = Math.max(leftMax, arr[l++]); &#125;else&#123; value += Math.max(0, rightMax - arr[r]); rightMax = Math.max(rightMax, arr[r--]); &#125; &#125; return value; &#125; public static void main(String[] args)&#123; int[] arr = &#123;3, 1, 2, 4&#125;; System.out.println(getWater(arr)); &#125;&#125; 3.给定一个数组，长度大于2。找出不相交的两个子数组，情况是 很多的。请返回这么多情况中，两个不相交子数组最大的和。例如:-1,3,4,-9,1,2当两个不相交子数组为[3,4]和[1,2]时，可以得到最大的和为 10。 1234567891011121314151617181920212223242526272829303132public class TwoSubArrayMaxSum &#123; public static int twoSubArrayMaxSum(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return 0; &#125; int[] rArray = new int[arr.length]; int max = Integer.MIN_VALUE; int cur = 0; for (int i = arr.length - 1; i &gt; 0; i--)&#123; cur += arr[i]; max = Math.max(cur, max); rArray[i] = max; cur = cur &lt; 0 ? 0 : cur; &#125; int res = Integer.MIN_VALUE; max = Integer.MIN_VALUE; cur = 0; for (int i = 0; i &lt; arr.length - 1; i++)&#123; cur += arr[i]; max = Math.max(max, cur); res = Math.max(res, max + rArray[i + 1]); cur = cur &lt; 0 ? 0 : cur; &#125; return res; &#125; public static void main(String[] args) &#123; int[] arr = &#123;-1, 3, 4, -9, 1, 2&#125;; System.out.println(twoSubArrayMaxSum(arr)); &#125;&#125; 使用预处理数组rArray[]，得到从右往左的最大子数组 4.给定一个长度为N(N&gt;1)的整型数组arr，可以划分成左右两个部分，左部分为arr[0..K]，右部分为arr[K+1..N-1]，K可以取 值的范围是[0,N-2]。求这么多划分方案中，左部分中的最大值 减去右部分最大值的绝对值中，最大是多少?例如:[2,7,3,1,1]，当左部分为[2,7]，右部分为[3,1,1]时， 左部分中的最大值减去右部分最大值的绝对值为4。当左部分为 [2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最 大值的绝对值为6。还有很多划分方案，但最终返回6。 123456789101112131415public class MaxABSBetweenLeftAndRight &#123; public static int maxABS(int[] arr)&#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++)&#123; max = Math.max(arr[i], max); &#125; return max - Math.min(arr[0], arr[arr.length - 1]); &#125; public static void main(String[] args)&#123; int[] arr = &#123;2, 7, 3, 1, 1&#125;; System.out.println(maxABS(arr)); &#125;&#125; 理解其中的诀窍：Max在左，则与最右边的数相减取MaxABS;Max在右，则与最左边的数相减取MaxABS。两者比较去大数。","tags":[{"name":"算法","slug":"算法","permalink":"http://DeveloperYangyang.github.io/tags/算法/"}]},{"title":"生活感悟","date":"2017-08-05T14:20:18.000Z","path":"2017/08/05/生活感悟/","text":"研究生生活已经过了大半，从当初的后悔读研，不喜欢老师分配的项目，不喜欢被困在实验室枯燥的过日子，到现在的淡然面对，可能是因为离毕业不远了吧。现在想想当初自己考研应该是有逃离工作的念想，也有对自己能力的不信任。现在想想，我应该首先让自己强大起来，拥有追求梦想和决定生活的能力。 说说这研究生学到的，主要是掌握了时间和分析解决问题的能力 1.掌握时间：学自水湄物语的《30岁前的每一天》，使用记事本来规划自己的时间和生活1.至少连续7天忠实记录下每天超过30分钟的活动，几点到几点，干了什么，找出自己的时间都用去了哪里，接下来就可以根据PDCA模型循环调整每天的活动（Plan计划-D执行-Check反馈-Adjust调整） 2.在一天的开始写下自己今天要做的每一件事，记得任务不要排太慢，要预留时间空间，并且把任务分解成2小时内能完成的 3.估算每一件事需要用到的时间 4.对写下的事情进行取舍，做出排序，人的时间是有限的，一定要为重要的事情留出最多的时间和精力 5.根据排序一件件完成笔记本上写下的事情，并记录下实际使用的时间（重要的是执行！） 6.反馈和调整，记录当日需要反省的事情，找出自认为不足的地方，根据反馈内容，提出小小的改进意见，并在第二天就执行 7.学习和实践，记录当天对自己有所触动的事情或收获，并结合自己的情况想想可不可以移到自己的身上实践 ***每天重复2~7*** 8.一个月后，一年后，根据6、7建立自己的经验库 9.每月的计划可以分为几大模块，比如工作计划、生活与健康、学习计划等 其他的么，学会给自己的生活增加一点仪式感，努力让生活慢一点，庄严一点，色彩丰富一点。 2.分析解决问题的能力1.分析问题不要着急，先把问题搞明白 2.把大问题分成一个个小问题（这是要学习的） 3.分清楚具体需求，一步一步实现（反而这个是最简单的） ————这在编程开发里很实用 3.对于朋友友情的终极目的是理解、默契。 无论什么时候，无论怎样的心情，换位思考一下。 决定帮助朋友的时候，就不会去指望着他来回报。 我羡慕你，但我还是做我自己—————————————————————————end这个是分享给看见这篇文章的你，希望对你有用。 序号 任务 对应 1 写下任务 Plan 2 估算时间 3 做出取舍（排序） 4 分解任务（分到两小时内） Do 5 预留时间 6 反馈调整（反省不足，改进，执行） Check ＆ Adjust 7 学习实践（记录事情与收获） 计划 序号 优先度 内容 计划时间 完成与否 1 A1 2 A2 3 A3 4 A4 5 B1 6 B2 7 B3 执行 时间 内容 计划时间 实际时间 9：00 - 10:00 10：00 - 11：00 11：30 - 1：30 中饭及午休 1：40 - 3：00 3：20 - 5：00 5：30 - 7：30 晚饭及休息放松 7：40 - 9：00 9：20 - 10：30 反省与改进: 个人整体学习计划:1.工作与学习知识2.生活技能与知识 Tips:","tags":[{"name":"研究生生活","slug":"研究生生活","permalink":"http://DeveloperYangyang.github.io/tags/研究生生活/"}]},{"title":"Markdown语法","date":"2017-08-05T07:12:18.000Z","path":"2017/08/05/Markdown语法/","text":"(转载网络资源)Guide这是一篇讲解如何正确使用 Markdown 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。 引用文本：Markdown is a text formatting syntax inspired 语法指导 普通内容这段内容展示了在内容里面一些小的格式，比如： 加粗 - **加粗** 倾斜 - *倾斜* 删除线 - ~~删除线~~ Code 标记 - Code 标记 超级链接 - [超级链接](http://github.com) username@gmail.com - [username@gmail.com](mailto:username@gmail.com) 提及用户@foo @bar @someone … 通过 @ 可以在发帖和回帖里面提及用户，信息提交以后，被提及的用户将会收到系统通知。以便让他来关注这个帖子或回帖。 表情符号 Emoji支持表情符号，你可以用系统默认的 Emoji 符号（无法支持 Windows 用户）。也可以用图片的表情，输入 : 将会出现智能提示。 一些表情例子:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: 大标题 - Heading 3你可以选择使用 H2 至 H6，使用 ##(N) 打头，H1 不能使用，会自动转换成 H2。 NOTE: 别忘了 # 后面需要有空格！ Heading 4Heading 5Heading 6图片12345![alt 文本](http://image-path.png)![alt 文本](http://image-path.png &quot;图片 Title 值&quot;)![设置图片宽度高度](http://image-path.png =300x200)![设置图片宽度](http://image-path.png =300x)![设置图片高度](http://image-path.png =x200) 代码块普通123*emphasize* **strong**_emphasize_ __strong__@a = 1 语法高亮支持如果在 123456789##### 演示 Ruby 代码高亮```rubyclass PostController &lt; ApplicationController def index @posts = Post.last_actived.limit(10) endend 演示 Rails View 高亮123&lt;%= @posts.each do |post| %&gt;&lt;div class=\"post\"&gt;&lt;/div&gt;&lt;% end %&gt; 演示 YAML 文件123zh-CN: name: 姓名 age: 年龄 Tip: 语言名称支持下面这些: ruby, python, js, html, erb, css, coffee, bash, json, yml, xml … 有序、无序列表无序列表 Ruby Rails ActiveRecord Go Gofmt Revel Node.js Koa Express 有序列表 Node.js Express Koa Sails Ruby Rails Sinatra Go 表格如果需要展示数据什么的，可以选择使用表格哦 header 1 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 段落留空白的换行，将会被自动转换成一个段落，会有一定的段落间距，便于阅读。 请注意后面 Markdown 源代码的换行留空情况。 视频插入目前支持 Youtube 和 Youku 两家的视频插入，你只需要复制视频播放页面，浏览器地址栏的网页 URL 地址，并粘贴到话题／回复文本框，提交以后将自动转换成视频播放器。 例如Youtube https://www.youtube.com/watch?v=CvVvwh3BRq8 Vimeo https://vimeo.com/199770305 Youku http://v.youku.com/v_show/id_XMjQzMTY1MDk3Ng==.html ···","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://DeveloperYangyang.github.io/tags/Markdown/"}]},{"title":"九九乘法表","date":"2017-08-05T05:43:10.000Z","path":"2017/08/05/九九乘法表/","text":"使用Python实现九九乘法表1.利用循环来实现一般方法 12345678# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9for i in range(1, 10): for j in range(1, i+1): print(&apos;%d * %d = %d&apos; % (i, j, i*j),end = &apos;\\t&apos;) print(&apos;\\n&apos;) 使用format，增强可读性 12345678# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9for i in range(1, 10): for j in range(1, i+1): print(&apos;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&apos;.format(i, j, i*j),end = &apos;\\t&apos;) print(&apos;\\n&apos;) 2.利用递归来实现123456789101112# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9def f(i): if i&gt;=1: f(i-1) print([&apos;%d * %d = %d&apos; % (j,i,i*j) for j in range(1, i+1)])if __name__ == &apos;__main__&apos;: f(9)","tags":[{"name":"python","slug":"python","permalink":"http://DeveloperYangyang.github.io/tags/python/"}]},{"title":"基于pickle模块的学生管理系统","date":"2017-08-03T12:54:39.000Z","path":"2017/08/03/基于pickle模块的学生管理系统/","text":"利用模块pickle完成学生信息管理系统Python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。 学生系统功能分为 Add Delect Show Save Read Quit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-import pickleclass Student: def __init__(self, studentID, name, sex, classID): self.studentID = studentID self.name = name self.sex = sex self.classID = classIDclass StudentManager: def __init__(self): self.students = [] def mainMenu(self): print(&apos;\\nTips:&apos;) print(&apos;1.Add studentInfo&apos;) print(&apos;2.Delect studentInfo&apos;) print(&apos;3.Show studentInfo&apos;) print(&apos;4.Save studentInfo&apos;) print(&apos;5.Read studentInfo&apos;) print(&apos;0.Quit&apos;) flag = input(&apos;Select Operation:&apos;) while (flag &lt; &apos;0&apos; or flag &gt; &apos;5&apos;): print(&apos;Input Error!&apos;) flag = input(&apos;Select Again:&apos;) print(&apos;------------&apos;) if (flag == &apos;1&apos;): self.addStu() self.mainMenu() if (flag == &apos;2&apos;): self.delStu() self.mainMenu() if (flag == &apos;3&apos;): self.printStu() self.mainMenu() if (flag == &apos;4&apos;): self.writeStu() self.mainMenu() if (flag == &apos;5&apos;): self.readStu() self.mainMenu() if (flag == &apos;0&apos;): self.writeStu() # Save before quit print(&apos;End&apos;) def addStu(self): studentID = input(&apos;Plaese input studentID: &apos;) while (self.findByID(studentID) != -1): print(&apos;studentID repeat, please input again&apos;) studentID = input(&apos;Please input studentID again&apos;) name = input(&apos;Please input student name: &apos;) sex = input(&apos;Please input student sex: &apos;) sex while ((sex != &apos;f&apos;) and (sex != &apos;m&apos;)): print(&apos;Sex input error, please input sex again&apos;) sex = input(&apos;Please input student sex again: &apos;) classID = input(&apos;Please input student classID: &apos;) student = Student(studentID, name, sex, classID) self.students.append(student) print(&apos;Add success!&apos;) def delStu(self): studentID = input(&apos;Please input the studentID you want to del: &apos;) i = self.findByID(studentID) while (i == -1): print(&apos;No this studentID, please input studentID again!&apos;) studentID = input(&quot;Please input the studentID again: &quot;) i = self.findByID(studentID) del(self.students[i]) print(&apos;Del success!&apos;) def printStu(self): print(&apos;----------&apos;) print(&apos;%7s%7s%7s%7s&apos;%(&apos;StudentID&apos;, &apos;Name&apos;, &apos;Sex&apos;, &apos; ClassID&apos;)) for student in self.students: print(&apos;%7s%7s%7s%7s&apos;%(student[&apos;studentID&apos;], student[&apos;name&apos;], student[&apos;sex&apos;], student[&apos;classID&apos;])) def findByID(self, studentID): i = 0; for student in self.students: if (student[&apos;studentID&apos;] == studentID): return i # return number i = i+1 return -1 # find fail def writeStu(self): try: fout = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;wb&apos;) except IOError as e: ###python3 print(&apos;No file exist!&apos;) else: pickle.dump(self.students, fout) fout.close() print(&apos;Save success!&apos;) def readStu(self): try: fin = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;rb&apos;) except FileNotFoundError as e: ### python3: as print(&apos;No file exist, please save first!&apos;) else: print(&apos;On reading&apos;, end=&apos;&apos;) print(&apos;...&apos;, end=&apos;&apos;) self.students = pickle.load(fin) print(&apos;...&apos;) print(&apos;Read file success!&apos;) fin.close()sm = StudentManager()print(&apos;\\n\\n&apos;)print(&apos;===========================&apos;)print(&apos; StudentManagerSystem&apos;)print(&apos;===========================&apos;)sm.readStu()sm.mainMenu() 写完后发现一直报错 12self.students = pickle.load(fin)EOFError: Ran out of input 最后在Stack OverFlow找到答案。因为读取的文件为空。 解决办法：在save.db里面事先写入数据 123456789101112131415# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-import picklestudent = &#123;&apos;studentID&apos;: &apos;0001&apos;, &apos;name&apos;:&apos;W&apos;, &apos;sex&apos;: &apos;F&apos;, &apos;classID&apos;:&apos;1111&apos;&#125;students = []students.append(student)fout = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;wb&apos;)pickle.dump(students, fout)print(&apos;Save success!&apos;)fout.close()","tags":[{"name":"python","slug":"python","permalink":"http://DeveloperYangyang.github.io/tags/python/"}]}]