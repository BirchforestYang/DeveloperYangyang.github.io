[{"title":"牛客20170809算法总结","date":"2017-08-15T08:49:44.000Z","path":"2017/08/15/牛客20170809算法总结/","text":"0.铺垫：数组中的最大子数组1234567891011121314151617181920 public class SubArrayMaxSum &#123; public static int maxSum(int[] arr) &#123; if (arr == null || arr.length == 0)&#123; return 0; &#125; int max = Integer.MIN_VALUE; int cur = 0; for (int i = 0; i != arr.length; i++)&#123; cur += arr[i]; max = Math.max(max, cur); cur = cur &lt; 0 ? 0:cur; &#125; return max; &#125; public static void main(String[] args)&#123; int[] arr1 = &#123;-2, -3, -5, 40, -10, -10, 100, 1&#125;; System.out.println(maxSum(arr1)); &#125;&#125; 1.给定一个矩阵matrix，其中的值有正、有负、有0，返回子矩阵 的最大累加和。例如，矩阵matrix为: -90 48 78 64 -40 64 -81 -7 66 其中，最大累加和的子矩阵为: 48 78 -40 64 -7 66 所以返回累加和209。 例如，matrix为: -1 -1 -1 -1 2 2 -1 -1 -1 其中，最大累加和的子矩阵为: 2 2 所以返回累加和4。 1234567891011121314151617181920212223242526272829public class SubMatrixMaxSum &#123; public static int maxSum(int[][] m)&#123; if (m == null || m.length == 0 || m[0].length ==0)&#123; return 0; &#125; int max = Integer.MIN_VALUE; int cur = 0; int[] s = null; for (int i = 0; i != m.length; i++)&#123; s = new int[m[0].length]; for (int j = i; j != m[0].length; j++)&#123; cur = 0; for (int k =0; k != s.length; k++)&#123; s[k] += m[j][k]; cur += s[k]; max = Math.max(max, cur); cur = cur &lt; 0 ? 0 : cur; &#125; &#125; &#125; return max; &#125; public static void main(String[] args)&#123; int[][] matrix =&#123;&#123; -90, 48, 78 &#125;, &#123; 64, -40, 64 &#125;, &#123; -81, -7, 66 &#125;&#125;; System.out.println(maxSum(matrix)); &#125;&#125; 关键点：累加 2.给定一个数组，每个位置的值代表一个高度。那么整个数组可以看过是一个直方图。如果把这个直方图当做容器的话，求这个容器能装多少水。例如:3,1,2,4 代表第一个位置高度为3，第二个位置高度为1，第三个位置高度为2， 第四个位置高度为4。3,1,2,4这个数组代表的容器可以装3格的水。 123456789101112131415161718192021222324252627282930public class WaterMaxProblem &#123; public static int getWater(int[] arr)&#123; if (arr == null || arr.length &lt; 3)&#123; return 0; &#125; int value = 0; int leftMax = arr[0]; int rightMax = arr[arr.length - 1]; int l = 1; int r = arr.length - 2; while ( l &lt;= r)&#123; if (leftMax &lt;= rightMax)&#123; value += Math.max(0, leftMax - arr[l]); leftMax = Math.max(leftMax, arr[l++]); &#125;else&#123; value += Math.max(0, rightMax - arr[r]); rightMax = Math.max(rightMax, arr[r--]); &#125; &#125; return value; &#125; public static void main(String[] args)&#123; int[] arr = &#123;3, 1, 2, 4&#125;; System.out.println(getWater(arr)); &#125;&#125; 3.给定一个数组，长度大于2。找出不相交的两个子数组，情况是 很多的。请返回这么多情况中，两个不相交子数组最大的和。例如:-1,3,4,-9,1,2当两个不相交子数组为[3,4]和[1,2]时，可以得到最大的和为 10。 1234567891011121314151617181920212223242526272829303132public class TwoSubArrayMaxSum &#123; public static int twoSubArrayMaxSum(int[] arr)&#123; if (arr == null || arr.length &lt; 2)&#123; return 0; &#125; int[] rArray = new int[arr.length]; int max = Integer.MIN_VALUE; int cur = 0; for (int i = arr.length - 1; i &gt; 0; i--)&#123; cur += arr[i]; max = Math.max(cur, max); rArray[i] = max; cur = cur &lt; 0 ? 0 : cur; &#125; int res = Integer.MIN_VALUE; max = Integer.MIN_VALUE; cur = 0; for (int i = 0; i &lt; arr.length - 1; i++)&#123; cur += arr[i]; max = Math.max(max, cur); res = Math.max(res, max + rArray[i + 1]); cur = cur &lt; 0 ? 0 : cur; &#125; return res; &#125; public static void main(String[] args) &#123; int[] arr = &#123;-1, 3, 4, -9, 1, 2&#125;; System.out.println(twoSubArrayMaxSum(arr)); &#125;&#125; 使用预处理数组rArray[]，得到从右往左的最大子数组 4.给定一个长度为N(N&gt;1)的整型数组arr，可以划分成左右两个部分，左部分为arr[0..K]，右部分为arr[K+1..N-1]，K可以取 值的范围是[0,N-2]。求这么多划分方案中，左部分中的最大值 减去右部分最大值的绝对值中，最大是多少?例如:[2,7,3,1,1]，当左部分为[2,7]，右部分为[3,1,1]时， 左部分中的最大值减去右部分最大值的绝对值为4。当左部分为 [2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最 大值的绝对值为6。还有很多划分方案，但最终返回6。 123456789101112131415public class MaxABSBetweenLeftAndRight &#123; public static int maxABS(int[] arr)&#123; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; arr.length; i++)&#123; max = Math.max(arr[i], max); &#125; return max - Math.min(arr[0], arr[arr.length - 1]); &#125; public static void main(String[] args)&#123; int[] arr = &#123;2, 7, 3, 1, 1&#125;; System.out.println(maxABS(arr)); &#125;&#125; 理解其中的诀窍：Max在左，则与最右边的数相减取MaxABS;Max在右，则与最左边的数相减取MaxABS。两者比较去大数。","tags":[{"name":"算法","slug":"算法","permalink":"http://developeryang.top/tags/算法/"}]},{"title":"生活感悟","date":"2017-08-05T14:20:18.000Z","path":"2017/08/05/生活感悟/","text":"研究生生活已经过了大半，从当初的后悔读研，不喜欢老师分配的项目，不喜欢被困在实验室枯燥的过日子，到现在的淡然面对，可能是因为离毕业不远了吧。现在想想当初自己考研应该是有逃离工作的念想，也有对自己能力的不信任。现在想想，我应该首先让自己强大起来，拥有追求梦想和决定生活的能力。 说说这研究生学到的，主要是掌握了时间和分析解决问题的能力 1.掌握时间：学自水湄物语的《30岁前的每一天》，使用记事本来规划自己的时间和生活1.至少连续7天忠实记录下每天超过30分钟的活动，几点到几点，干了什么，找出自己的时间都用去了哪里，接下来就可以根据PDCA模型循环调整每天的活动（Plan计划-D执行-Check反馈-Adjust调整） 2.在一天的开始写下自己今天要做的每一件事，记得任务不要排太慢，要预留时间空间，并且把任务分解成2小时内能完成的 3.估算每一件事需要用到的时间 4.对写下的事情进行取舍，做出排序，人的时间是有限的，一定要为重要的事情留出最多的时间和精力 5.根据排序一件件完成笔记本上写下的事情，并记录下实际使用的时间（重要的是执行！） 6.反馈和调整，记录当日需要反省的事情，找出自认为不足的地方，根据反馈内容，提出小小的改进意见，并在第二天就执行 7.学习和实践，记录当天对自己有所触动的事情或收获，并结合自己的情况想想可不可以移到自己的身上实践 ***每天重复2~7*** 8.一个月后，一年后，根据6、7建立自己的经验库 9.每月的计划可以分为几大模块，比如工作计划、生活与健康、学习计划等 其他的么，学会给自己的生活增加一点仪式感，努力让生活慢一点，庄严一点，色彩丰富一点。 2.分析解决问题的能力1.分析问题不要着急，先把问题搞明白 2.把大问题分成一个个小问题（这是要学习的） 3.分清楚具体需求，一步一步实现（反而这个是最简单的） ————这在编程开发里很实用 3.对于朋友友情的终极目的是理解、默契。 无论什么时候，无论怎样的心情，换位思考一下。 决定帮助朋友的时候，就不会去指望着他来回报。 我羡慕你，但我还是做我自己—————————————————————————end这个是分享给看见这篇文章的你，希望对你有用。 序号 任务 对应 1 写下任务 Plan 2 估算时间 3 做出取舍（排序） 4 分解任务（分到两小时内） Do 5 预留时间 6 反馈调整（反省不足，改进，执行） Check ＆ Adjust 7 学习实践（记录事情与收获） 计划 序号 优先度 内容 计划时间 完成与否 1 A1 2 A2 3 A3 4 A4 5 B1 6 B2 7 B3 执行 时间 内容 计划时间 实际时间 9：00 - 10:00 10：00 - 11：00 11：30 - 1：30 中饭及午休 1：40 - 3：00 3：20 - 5：00 5：30 - 7：30 晚饭及休息放松 7：40 - 9：00 9：20 - 10：30 反省与改进: 个人整体学习计划:1.工作与学习知识2.生活技能与知识 Tips:","tags":[{"name":"研究生生活","slug":"研究生生活","permalink":"http://developeryang.top/tags/研究生生活/"}]},{"title":"Markdown语法","date":"2017-08-05T07:12:18.000Z","path":"2017/08/05/Markdown语法/","text":"(转载网络资源)Guide这是一篇讲解如何正确使用 Markdown 的排版示例，学会这个很有必要，能让你的文章有更佳清晰的排版。 引用文本：Markdown is a text formatting syntax inspired 语法指导 普通内容这段内容展示了在内容里面一些小的格式，比如： 加粗 - **加粗** 倾斜 - *倾斜* 删除线 - ~~删除线~~ Code 标记 - Code 标记 超级链接 - [超级链接](http://github.com) username@gmail.com - [username@gmail.com](mailto:username@gmail.com) 提及用户@foo @bar @someone … 通过 @ 可以在发帖和回帖里面提及用户，信息提交以后，被提及的用户将会收到系统通知。以便让他来关注这个帖子或回帖。 表情符号 Emoji支持表情符号，你可以用系统默认的 Emoji 符号（无法支持 Windows 用户）。也可以用图片的表情，输入 : 将会出现智能提示。 一些表情例子:smile: :laughing: :dizzy_face: :sob: :cold_sweat: :sweat_smile: :cry: :triumph: :heart_eyes: :relaxed: :sunglasses: :weary: :+1: :-1: :100: :clap: :bell: :gift: :question: :bomb: :heart: :coffee: :cyclone: :bow: :kiss: :pray: :sweat_drops: :hankey: :exclamation: :anger: 大标题 - Heading 3你可以选择使用 H2 至 H6，使用 ##(N) 打头，H1 不能使用，会自动转换成 H2。 NOTE: 别忘了 # 后面需要有空格！ Heading 4Heading 5Heading 6图片12345![alt 文本](http://image-path.png)![alt 文本](http://image-path.png &quot;图片 Title 值&quot;)![设置图片宽度高度](http://image-path.png =300x200)![设置图片宽度](http://image-path.png =300x)![设置图片高度](http://image-path.png =x200) 代码块普通123*emphasize* **strong**_emphasize_ __strong__@a = 1 语法高亮支持如果在 123456789##### 演示 Ruby 代码高亮```rubyclass PostController &lt; ApplicationController def index @posts = Post.last_actived.limit(10) endend 演示 Rails View 高亮123&lt;%= @posts.each do |post| %&gt;&lt;div class=\"post\"&gt;&lt;/div&gt;&lt;% end %&gt; 演示 YAML 文件123zh-CN: name: 姓名 age: 年龄 Tip: 语言名称支持下面这些: ruby, python, js, html, erb, css, coffee, bash, json, yml, xml … 有序、无序列表无序列表 Ruby Rails ActiveRecord Go Gofmt Revel Node.js Koa Express 有序列表 Node.js Express Koa Sails Ruby Rails Sinatra Go 表格如果需要展示数据什么的，可以选择使用表格哦 header 1 header 3 cell 1 cell 2 cell 3 cell 4 cell 5 cell 6 段落留空白的换行，将会被自动转换成一个段落，会有一定的段落间距，便于阅读。 请注意后面 Markdown 源代码的换行留空情况。 视频插入目前支持 Youtube 和 Youku 两家的视频插入，你只需要复制视频播放页面，浏览器地址栏的网页 URL 地址，并粘贴到话题／回复文本框，提交以后将自动转换成视频播放器。 例如Youtube https://www.youtube.com/watch?v=CvVvwh3BRq8 Vimeo https://vimeo.com/199770305 Youku http://v.youku.com/v_show/id_XMjQzMTY1MDk3Ng==.html ···","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://developeryang.top/tags/Markdown/"}]},{"title":"九九乘法表","date":"2017-08-05T05:43:10.000Z","path":"2017/08/05/九九乘法表/","text":"使用Python实现九九乘法表1.利用循环来实现一般方法 12345678# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9for i in range(1, 10): for j in range(1, i+1): print(&apos;%d * %d = %d&apos; % (i, j, i*j),end = &apos;\\t&apos;) print(&apos;\\n&apos;) 使用format，增强可读性 12345678# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9for i in range(1, 10): for j in range(1, i+1): print(&apos;&#123;0&#125; * &#123;1&#125; = &#123;2&#125;&apos;.format(i, j, i*j),end = &apos;\\t&apos;) print(&apos;\\n&apos;) 2.利用递归来实现123456789101112# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-# 9 * 9def f(i): if i&gt;=1: f(i-1) print([&apos;%d * %d = %d&apos; % (j,i,i*j) for j in range(1, i+1)])if __name__ == &apos;__main__&apos;: f(9)","tags":[{"name":"python","slug":"python","permalink":"http://developeryang.top/tags/python/"}]},{"title":"基本算法整理","date":"2017-08-03T13:34:53.000Z","path":"2017/08/03/基本算法整理/","text":"开始整理我在其他地方的Blog 排序算法要素：1. 时间性能2. 辅助空间3. 算法的复杂性4. 稳定性 1. 插入排序：插入排序基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入排序的基本思想是：每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入 12345678910111213141516171819202122232425262728293031323334//平均时间复杂度O(n^2)//最优时间复杂度O(n)//最坏时间复杂度O(n^2)//空间复杂度O(1)//稳定#include &lt;stdio.h&gt;void InsertSort(int a[], int len)&#123; int i, j; int temp; for (i = 1; i &lt; len; i++) &#123; temp = a[i]; j = i - 1; while (j &gt;= 0 &amp;&amp; a[j] &gt; temp) &#123; a[j + 1] = a[j]; j--; &#125; a[j + 1]= temp; &#125;&#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); InsertSort(a, 8); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0; &#125; 2. 希尔排序：希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。希尔排序是是插入排序的一种更高效的改进版本 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 1234567891011121314151617181920212223242526272829303132333435//平均时间复杂度O(n^1.3)//空间复杂度O(1)//最优时间复杂度O(n)//最坏时间复杂度O(n^2)//不稳定#include &lt;stdio.h&gt;void shellSort(int a[], int len)&#123; int gap, i, j; int temp; for (gap = len / 2; gap &gt; 0; gap /= 2) &#123; for (i = gap; i &lt; len; i++) &#123; temp = a[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; a[j] &gt; temp; j -= gap) &#123; a[j+gap] = a[j]; &#125; a[j+gap] = temp; &#125; &#125; &#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); shellSort(a, 8); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0; &#125; 3. 冒泡排序：冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端。 一般情况下不要用冒泡排序, 除非 n &lt;= 16 冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//使用flag来避免因原数组已经有序而进行无意义的判断//平均时间复杂度O(n^2)//最优时间复杂度O(n)//最坏时间复杂度O(n^2)//空间复杂度O(1)//稳定#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;void swap(int *a, int *b)&#123; int temp; temp = *a; *a = *b; *b = temp;&#125;void BubbleSort(int a[],int n)&#123; int i,j; bool flag = true; for (i = 1; i &lt; n &amp;&amp; flag; i++) &#123; flag = false; for (j = n-1; j &gt;= i; j--) &#123; if (a[j] &gt; a[j+1]) &#123; swap(&amp;a[j], &amp;a[j+1]); flag = true; &#125; &#125; &#125;&#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); BubbleSort(a,8); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0; &#125; 4. 快速排序：快速排序（Quicksort）是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 快速排序是分区交换，属于交换排序，是冒泡排序的改进。当待排序的关键字是随机分布时，快速排序的平均时间最短。 快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。步骤为： 从数列中挑出一个元素，称为”基准”（pivot）， 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。 递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//平均时间复杂度O(n^2)//空间复杂度O(logn)~O(n)//最优时间复杂度O(nlogn)//最坏时间复杂度O(n^2)//不稳定#include &lt;stdio.h&gt;void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;int Partition(int a[], int low, int high)&#123; int pivotkey; pivotkey = a[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; a[high] &gt;= pivotkey) &#123; high--; &#125; a[low] = a[high]; while (low &lt; high &amp;&amp; a[low] &lt;= pivotkey) &#123; low++; &#125; a[high] = a[low]; &#125; a[low] = pivotkey; return low;&#125;void QuickSort(int a[], int low, int high)&#123; int pivotkey = a[low]; if (low &lt; high) &#123; pivotkey = Partition(a, low, high); QuickSort(a, low, pivotkey-1); QuickSort(a, pivotkey+1, high); &#125; else&#123; return; &#125;&#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); QuickSort(a, 0, 7); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0; &#125; 5. 选择排序：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 最好最坏的比较次数一样多。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 123456789101112131415161718192021222324252627282930313233343536373839//平均时间复杂度O(n^2)//空间复杂度O(1)//最优时间复杂度O(n^2)//最坏时间复杂度O(n^2)//不稳定#include &lt;stdio.h&gt;void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;void SimpleSelectSort(int a[], int n)&#123; int i, j, min = 0; for (i = 0; i &lt; n; i++) &#123; min = i; for (j = i+1; j &lt;= n; j++) &#123; if (a[min] &gt; a[j]) &#123; min = j; &#125; &#125; if (i != min) &#123; swap(&amp;a[min], &amp;a[i]); &#125; &#125;&#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); SimpleSelectSort(a, 8); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0;&#125; 6.堆排序:在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作： 最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点创建最大堆（Build_Max_Heap）：将堆所有数据重新排序堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//平均时间复杂度O(nlog2(n))//空间复杂度O(1)//最优时间复杂度O(nlog2(n))//最坏时间复杂度O(nlog2(n))//不稳定#include &lt;stdio.h&gt;void swap(int *a, int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;void Max_Heapify(int a[], int start, int end)&#123; int dad = start; int son = dad * 2 + 1; while (son &lt;= end) &#123; if (son + 1 &lt;= end &amp;&amp; a[son] &lt; a[son + 1]) &#123; son++; &#125; if (a[dad] &gt; a[son]) &#123; return; &#125;else&#123; swap(&amp;a[dad], &amp;a[son]); dad = son; son = dad * 2 + 1; &#125; &#125; &#125;void HeapSort(int a[], int len)&#123; int i; for (i = len / 2 - 1; i &gt;= 0; i--) &#123; Max_Heapify(a, i, len - 1); &#125; for (i = len - 1; i &gt; 0; i--) &#123; swap(&amp;a[0], &amp;a[i]); Max_Heapify(a, 0, i-1); &#125;&#125;int main()&#123; int a[8]; printf(&quot;Please input the number:\\n&quot;); for(int i=0;i&lt;8;i++) scanf(&quot;%d&quot;,&amp;a[i]); HeapSort(a, 8); for (int i=0; i&lt;8; i++) &#123; printf(&quot;%d\\n&quot;,a[i]); &#125; return 0;&#125; 7. 归并排序：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 1待补充","tags":[{"name":"算法","slug":"算法","permalink":"http://developeryang.top/tags/算法/"}]},{"title":"基于pickle模块的学生管理系统","date":"2017-08-03T12:54:39.000Z","path":"2017/08/03/基于pickle模块的学生管理系统/","text":"利用模块pickle完成学生信息管理系统Python的pickle模块实现了基本的数据序列和反序列化。通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储；通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。 学生系统功能分为 Add Delect Show Save Read Quit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-import pickleclass Student: def __init__(self, studentID, name, sex, classID): self.studentID = studentID self.name = name self.sex = sex self.classID = classIDclass StudentManager: def __init__(self): self.students = [] def mainMenu(self): print(&apos;\\nTips:&apos;) print(&apos;1.Add studentInfo&apos;) print(&apos;2.Delect studentInfo&apos;) print(&apos;3.Show studentInfo&apos;) print(&apos;4.Save studentInfo&apos;) print(&apos;5.Read studentInfo&apos;) print(&apos;0.Quit&apos;) flag = input(&apos;Select Operation:&apos;) while (flag &lt; &apos;0&apos; or flag &gt; &apos;5&apos;): print(&apos;Input Error!&apos;) flag = input(&apos;Select Again:&apos;) print(&apos;------------&apos;) if (flag == &apos;1&apos;): self.addStu() self.mainMenu() if (flag == &apos;2&apos;): self.delStu() self.mainMenu() if (flag == &apos;3&apos;): self.printStu() self.mainMenu() if (flag == &apos;4&apos;): self.writeStu() self.mainMenu() if (flag == &apos;5&apos;): self.readStu() self.mainMenu() if (flag == &apos;0&apos;): self.writeStu() # Save before quit print(&apos;End&apos;) def addStu(self): studentID = input(&apos;Plaese input studentID: &apos;) while (self.findByID(studentID) != -1): print(&apos;studentID repeat, please input again&apos;) studentID = input(&apos;Please input studentID again&apos;) name = input(&apos;Please input student name: &apos;) sex = input(&apos;Please input student sex: &apos;) sex while ((sex != &apos;f&apos;) and (sex != &apos;m&apos;)): print(&apos;Sex input error, please input sex again&apos;) sex = input(&apos;Please input student sex again: &apos;) classID = input(&apos;Please input student classID: &apos;) student = Student(studentID, name, sex, classID) self.students.append(student) print(&apos;Add success!&apos;) def delStu(self): studentID = input(&apos;Please input the studentID you want to del: &apos;) i = self.findByID(studentID) while (i == -1): print(&apos;No this studentID, please input studentID again!&apos;) studentID = input(&quot;Please input the studentID again: &quot;) i = self.findByID(studentID) del(self.students[i]) print(&apos;Del success!&apos;) def printStu(self): print(&apos;----------&apos;) print(&apos;%7s%7s%7s%7s&apos;%(&apos;StudentID&apos;, &apos;Name&apos;, &apos;Sex&apos;, &apos; ClassID&apos;)) for student in self.students: print(&apos;%7s%7s%7s%7s&apos;%(student[&apos;studentID&apos;], student[&apos;name&apos;], student[&apos;sex&apos;], student[&apos;classID&apos;])) def findByID(self, studentID): i = 0; for student in self.students: if (student[&apos;studentID&apos;] == studentID): return i # return number i = i+1 return -1 # find fail def writeStu(self): try: fout = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;wb&apos;) except IOError as e: ###python3 print(&apos;No file exist!&apos;) else: pickle.dump(self.students, fout) fout.close() print(&apos;Save success!&apos;) def readStu(self): try: fin = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;rb&apos;) except FileNotFoundError as e: ### python3: as print(&apos;No file exist, please save first!&apos;) else: print(&apos;On reading&apos;, end=&apos;&apos;) print(&apos;...&apos;, end=&apos;&apos;) self.students = pickle.load(fin) print(&apos;...&apos;) print(&apos;Read file success!&apos;) fin.close()sm = StudentManager()print(&apos;\\n\\n&apos;)print(&apos;===========================&apos;)print(&apos; StudentManagerSystem&apos;)print(&apos;===========================&apos;)sm.readStu()sm.mainMenu() 写完后发现一直报错 12self.students = pickle.load(fin)EOFError: Ran out of input 最后在Stack OverFlow找到答案。因为读取的文件为空。 解决办法：在save.db里面事先写入数据 123456789101112131415# !/Library/Frameworks/Python.framework/Versions/3.6/bin/python3# -*- coding: utf-8 -*-import picklestudent = &#123;&apos;studentID&apos;: &apos;0001&apos;, &apos;name&apos;:&apos;W&apos;, &apos;sex&apos;: &apos;F&apos;, &apos;classID&apos;:&apos;1111&apos;&#125;students = []students.append(student)fout = open(r&apos;/Users/yangyang/Developer/Python/file/save.db&apos;, &apos;wb&apos;)pickle.dump(students, fout)print(&apos;Save success!&apos;)fout.close()","tags":[{"name":"python","slug":"python","permalink":"http://developeryang.top/tags/python/"}]},{"title":"面试准备-iOS开发","date":"2017-07-27T12:58:10.000Z","path":"2017/07/27/面试准备-iOS开发/","text":"思考问题： RunLoop Cell 图片异步加载优化 iOS 函数式编程的实现 &amp;&amp; 响应式编程概念 内存恶鬼drawRect UIKit 性能调优(主要是UITableView) 优化UITableViewCell高度计算的那些事 高性能图片架构与设计 轻量化视图控制器 UIView的生命周期 高效设置圆角 事件的传递和响应机制 ReactiveCocoa 和 MVVM 入门","tags":[{"name":"iOS","slug":"iOS","permalink":"http://developeryang.top/tags/iOS/"}]},{"title":"面试准备-Objective-C","date":"2017-07-27T12:55:15.000Z","path":"2017/07/27/面试准备-Objective-C/","text":"《Effective Objective-C 2.0》– OC 中各种细节 《Objective-C 高级编程》– ARC、Block 和 GCD。 思考问题： 检测内存泄露 KVO与KVC原理、KVO、Notification、Delegate优缺点、最推荐的官方文档 GCD 与 NSOperation Runtime block atomic 线程安全、@synchronized 对象的深浅复制 招聘一个靠谱的iOS 消息传递机制 深入理解Objective-C：Category","tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://developeryang.top/tags/Objective-C/"}]},{"title":"面试准备-操作系统与编译","date":"2017-07-27T12:51:10.000Z","path":"2017/07/27/面试准备-操作系统与编译/","text":"源代码是怎么变成可执行文件的，每一步的作用是什么？（预编译，词法分析，语法分析，语义分析，中间语言生成目标代码生成，汇编，链接） 应用层、API、运行库、系统调用、操作系统内核之间的关系是什么？ 虚拟内存空间是什么，为什么要有虚拟内存空间。 静态链接和动态链接分别表示什么，大概是怎么实现的？ 可执行文件的结构如何？（分为哪些段） 它是怎么装载进内存的，为什么要分段，分页，页错误是什么？ 进程的内存格局是怎样的？（堆、栈、全局/静态区，代码区，常量区） 堆和栈的区别，函数调用和栈的关系 进程和线程的区别 异步和同步，串行，并发，并行的区别 多并发任务，仅多线程能加快速度么（不能，会变慢，有线程切换的开销） 多个线程之间可以共享那些数据 进程之间如何通信 介绍几种锁，他们的用途和区别多线程——《iOS多线程编程——GCD与NSOperation总结》操作系统和编译方面——《修改一个数字破解Mac上的应用》","tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://developeryang.top/tags/操作系统/"}]},{"title":"面试准备-网络","date":"2017-07-27T12:44:46.000Z","path":"2017/07/27/面试准备-网络/","text":"身边的一些资料： 【书】图解 TCP/IP 别人的总结 网上的一些问题： 简介 TCP 和 UDP 区别，他们位于哪一层？ 路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？ 描述TCP 协议三次握手，四次释放的过程。 TCP 协议是如何进行流量控制，拥塞控制的？ 为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理 关闭连接时，第四次握手失败怎么处理？ 你怎么理解分层和协议？ HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。 谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解。","tags":[{"name":"网络","slug":"网络","permalink":"http://developeryang.top/tags/网络/"}]},{"title":"面试准备-算法","date":"2017-07-26T09:00:04.000Z","path":"2017/07/26/面试准备-算法/","text":"这是我的找工作前的算法复习：准备使用《剑指 Offer》配合Leetcode来巩固知识。下面是来源于网上的面试常考题型字符串 最长回文子串 最长无重复子串 字符串转数字 KMP 算法 字符串全排列 翻转字符串 数组 求两个等长、有序数组的中位数（二分法） 求两个不等长、有序数组的中位数 旋转数组求最小值、旋转数组求查找某个值是否存在（二分法） 【每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题） 数组中出现次数超过一半的数字 第 k 大的数（拓展：最大的 k 个数） 有序数组中某个数字出现的次数（提示：利用二分搜索）链表 反转链表（使用递归和迭代两种解法，了解头插法） 删除链表的当前节点 删除倒数第 k 个节点 两个有序链表合并 复杂链表的复制 判断链表是否有环 两个链表的第一个公共节点（提示：考虑链表有环的情况） 删除链表中重复节点树 根据中序和后序遍历结果重建二叉树、根据中序和前序遍历结果重建二叉树 翻转二叉树 从上往下打印二叉树 (BFS 的思想) 判断某个数组是不是二叉树的后序遍历结果 (剑指 offer 第 24 题) 二叉树中和为某个值的路径 二叉树中某个节点的下一个节点 (强烈推荐准备一下，剑指 offer 第 58 题)栈 用两个栈实现队列、用两个队列实现栈 实现一个栈，可以用常数级时间找出栈中的最小值 判断栈的压栈、弹栈序列是否合法（剑指offer 第 22 题）排序了解以下排序的时间、空间复杂度，是否稳定，实现原理 归并排序、拓展：求数组中的逆序对个数 快速排序 重点：partion 函数的实现 堆排序 数组元素值域已知时，考虑 基数排序 和 桶排序位运算 给一个十进制数字，求它的二进制表示中，有多少个 1 (n &amp;= n - 1) 给一个数组，所有数字都出现了偶数次，只有一个出现了一次，找出这个数 给一个数组，所有数字都出现了三次，只有一个出现了一次，找出这个数 给一个数组，所有数组都出现了偶数次，只有两个数字出现了一次，找出这两个数 动态规划 背包问题 连续子数组的最大和 实现简单的正则表达式匹配","tags":[{"name":"算法","slug":"算法","permalink":"http://developeryang.top/tags/算法/"}]},{"title":"工作准备","date":"2017-02-17T08:02:24.000Z","path":"2017/02/17/工作准备/","text":"首先介绍下自己，一名——普通一本学校——非计算机专业——研二在读——的小硕，研究方向是无线充电。因为导师平时管的比较严没有实习机会，所以自己安排些时间来学习自己喜欢的技术和未来工作可能用到的技术。 像移动互联网时代已经走入平稳期，不会再有那么多的机会给新人，但我喜欢那一个App做完的成就感。 研一的时候断断续续看过一些关于iOS开发的blog和文档，自己也写过几个简单的demo。 目前手上有这几本书，还有一些视频教程。 准备一点一点重新来吧。 Objective-C编程(第2版)（已看过1遍） 精通iOS开发(第7版)（靠这个基本入门，能完成简单功能实现） 下面这几本是之后准备看的： Objective-C编程之道:iOS设计模式解析 Effective Objective C 2.0:编写高质量iOS与OS X代码的52个有效方法 Objective-C高级编程:iOS与OS X多线程和内存管理 未来的事谁都不知道，但多些准备总是好事。我可能会选择做测试开发，把App开发当做自己的爱好。","tags":[{"name":"工作","slug":"工作","permalink":"http://developeryang.top/tags/工作/"}]},{"title":"Hello World","date":"2017-02-17T00:44:02.000Z","path":"2017/02/17/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy Error with DTrace (Mac OS X)123&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; DTrace install may have issue, use this: 1$ npm install hexo --no-optional More info: Deployment","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://developeryang.top/tags/Hexo/"},{"name":"Blog","slug":"Blog","permalink":"http://developeryang.top/tags/Blog/"}]}]